---
declare global {
  var __TAURI__: any;
}
---

<script>
  import {
    addErrorLogs,
    addInvalidLogs,
    addValidLogs,
    EngineProps,
    engines,
    selectedEngine,
    setStatus,
  } from "../stores/engine";
  import { socket, socketRuntime, initSockets } from "../events/sockets";
  import { CellStatus } from "./CampaignCell";

  initSockets();

  // license control [determine screens] quickly
  const program = document.getElementById("appProgram");
  const elicense = document.getElementById("elicense");

  if (program && localStorage.getItem("authed")) {
    program.className = "row block";
  } else if (elicense) {
    elicense.className = "row block";
  }

  socketRuntime.addEventListener("open", () => {
    socketRuntime.send("loop");
  });

  socket.addEventListener("open", () => {
    socket.send("list-engines");
    socket.send("list-totals");
    socket.send("list-files");
    socket.send("feed");
    socket.send("config");

    setTimeout(() => {
      socket.send("list-campaign-stats");
    });
  });

  // new create
  const campaignCreateForm = document.getElementById("campaign-create-form");

  // tor
  const torSelect = document.getElementById("tor-select") as HTMLInputElement;
  const proxySelect = document.getElementById(
    "proxy-select"
  ) as HTMLInputElement;
  const lowpowerSelect = document.getElementById(
    "lowpower-select"
  ) as HTMLInputElement;
  const fileSelect = document.getElementById(
    "target-select"
  ) as HTMLInputElement;

  /*
   * List of web socket matchers * special for high performance
   */
  const ptp = "{" + '"' + "pengine" + '"' + ":" + '"'; // engine
  const ptpe = "{" + '"' + "epath" + '"' + ":" + '"'; // engine created
  const ptc = "{" + '"' + "count" + '"'; // file count
  const deptc = "{" + '"' + "depath" + '"'; // deleted campaign
  const cfin = "{" + '"' + "finished" + '"'; // crawl finished
  const vpaths = "{" + '"' + "path" + '"' + ":" + '"'; // valid paths
  const ipaths = "{" + '"' + "invalid_path" + '"' + ":" + '"'; // invalid paths
  const epaths = "{" + '"' + "error_path" + '"' + ":" + '"'; // errors paths
  const vlicense = "{" + '"' + "license"; // valid license;
  const cstarted = "{" + '"' + "started"; // started campaigns from pause
  const cpaused = "{" + '"' + "paused"; // paused campaigns from pause

  let firstCheck = false;

  function determineFinished(item: EngineProps) {
    return (
      item.errorUrls.size + item.invalidUrls.size + item.urls.size ===
      item.total
    );
  }

  function eventSub(event) {
    const raw = event.data;

    // license handling
    if (raw.startsWith(vlicense)) {
      const data = JSON.parse(raw);
      const { license } = data || {};

      // set local storage of license enabled and display view
      if (license) {
        if (program) {
          program.className = "row";
        }
        if (elicense) {
          elicense.className = "row hidden";
        }
        localStorage.setItem("authed", "true");
      } else {
        localStorage.removeItem("authed");

        if (firstCheck) {
          window.alert("License is invalid");
        }

        if (program) {
          program.className = "row hidden";
        }

        if (elicense) {
          elicense.className = "row";
        }
      }

      if (!firstCheck) {
        firstCheck = true;
      }
    }

    if (raw.startsWith(cfin)) {
      const data = JSON.parse(raw);
      const { finished, time } = data || {};

      setStatus(finished, CellStatus.FINISHED);
      console.log(time);
      return;
    }

    if (raw.startsWith(ptp)) {
      const np = JSON.parse(raw);
      const { pengine, ploc } = np || {};
      const eitem = engines.get()[pengine];

      if (eitem) {
        eitem.total = ploc ?? eitem.total ?? 0;

        engines.notify(pengine);

        if (determineFinished(eitem)) {
          setStatus(pengine, CellStatus.FINISHED);
        }
      }

      return;
    }

    if (raw.startsWith(epaths)) {
      const np = JSON.parse(raw);
      const { error_path, error_url } = np || {};
      const item = engines.get()[error_path];

      if (
        item &&
        error_url &&
        item.errorUrls &&
        !item.errorUrls.has(error_url)
      ) {
        item.errorUrls.add(error_url);

        if (selectedEngine.get() === error_path) {
          addErrorLogs(error_url);
        }

        if (determineFinished(item)) {
          setStatus(error_path, CellStatus.FINISHED);
        }

        engines.notify(error_path);
      }

      return;
    }

    if (raw.startsWith(ipaths)) {
      const np = JSON.parse(raw);

      const { invalid_url: url, invalid_path: path } = np || {};

      const item = engines.get()[path];

      if (item && item.invalidUrls && !item.invalidUrls.has(url)) {
        item.invalidUrls.add(url);

        if (selectedEngine.get() === path) {
          addInvalidLogs(url);
        }
        if (determineFinished(item)) {
          setStatus(path, CellStatus.FINISHED);
        }
      }

      return;
    }

    if (raw.startsWith(vpaths)) {
      const np = JSON.parse(raw);
      const { url, path } = np || {};
      const item = engines.get()[path];

      if (item && url && item.urls && !item.urls.has(url)) {
        item.urls.add(url);
        if (selectedEngine.get() === path) {
          addValidLogs(url);
        }
        if (determineFinished(item)) {
          setStatus(path, CellStatus.FINISHED);
        }
      }

      return;
    }

    if (raw.startsWith(ptpe)) {
      const np = JSON.parse(raw);
      const path = np && (np.epath as string);

      if (!engines.get()[path]) {
        const engineSource = {
          total: 0,
          valid: 0,
          urls: new Set(),
          invalidUrls: new Set(),
          errorUrls: new Set(),
          patterns: np?.patterns,
          paths: np?.paths,
          status: CellStatus.READY,
        };

        engines.setKey(path, engineSource);
      }
      return;
    }

    if (raw.startsWith(cstarted)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        setStatus(path, CellStatus.RUNNING);
      }
      return;
    }

    if (raw.startsWith(cpaused)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        setStatus(path, CellStatus.PAUSED);
      }
      return;
    }

    if (raw.startsWith(ptc)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        item.valid = np.count ?? item.valid ?? 0;
        engines.notify(path);

        if (determineFinished(item)) {
          setStatus(path, CellStatus.FINISHED);
        }
      }
      return;
    }

    // delete engine
    if (raw.startsWith(deptc)) {
      const np = JSON.parse(raw);
      const path = np && np.depath;

      if (engines.get()[path]) {
        engines.setKey(path, undefined);
      }
      return;
    }
  }

  socket.addEventListener("message", eventSub);
  socketRuntime.addEventListener("message", eventSub);

  const eform = document.getElementById("eform");
  const bufferform = document.getElementById("bufferform");
  const fsDelete = document.getElementById("fs-delete");

  bufferform?.addEventListener("submit", (event) => {
    const buffer: HTMLInputElement = bufferform.querySelector(
      'input[name="buffer"]'
    );
    const selected = buffer.value;

    socket.send("set-buffer " + selected);

    event.preventDefault();
  });

  fileSelect?.addEventListener("change", function (event) {
    socket.send("set-list " + this.value);
    event.preventDefault();
  });

  torSelect?.addEventListener("change", function (event) {
    socket.send("set-tor " + this.checked);
    event.preventDefault();
  });

  proxySelect?.addEventListener("change", function (event) {
    socket.send("set-proxy " + this.checked);
    event.preventDefault();
  });

  lowpowerSelect?.addEventListener("change", function (event) {
    socket.send("set-buffer " + this.checked);
    event.preventDefault();
  });

  fsDelete?.addEventListener("click", async () => {
    const cf = await window.confirm(
      "Are, you sure you want to delete this file?"
    );

    if (cf) {
      const selected = fileSelect?.value;

      if (selected) {
        socket.send("delete-file " + selected);
      }
    }
  });

  eform?.addEventListener("submit", (event) => {
    const engine: HTMLInputElement = eform.querySelector('input[name="ename"]');
    const epaths: HTMLInputElement = eform.querySelector(
      'input[name="epaths"]'
    );
    const epatterns: HTMLInputElement = eform.querySelector(
      'input[name="epatterns"]'
    );

    if (engine && engine.value) {
      const m = JSON.stringify({
        name: engine.value,
        paths: epaths.value,
        patterns: epatterns.value,
      });

      campaignCreateForm.className = "hidden";

      if (engines.get()[m]) {
        window.alert("Please enter a different engine name.");
      } else {
        // todo: send new engine created on submit or add optimistic update
        socket.send("create-engine " + m);
        socket.send("list-engines");
      }
    } else {
      window.alert("Please enter a engine name.");
    }
    event.preventDefault();
  });
</script>
