---
declare global {
  var __TAURI__: any;
}
---

<script>
  import {
    addErrorLogs,
    addInvalidLogs,
    addValidLogs,
    EngineProps,
    engines,
    selectedEngine,
    setStatus,
  } from "../stores/engine";
  import { socket, socketRuntime, initSockets } from "../events/sockets";
  import { CellStatus } from "./CampaignCell";
  import {
    baseConfig,
    fileMap,
    selectedFileOptionMutate,
  } from "../utils/file-set";

  initSockets();

  // license control [determine screens] quickly
  const program = document.getElementById("appProgram");
  const elicense = document.getElementById("elicense");

  if (program && localStorage.getItem("authed")) {
    program.className = "row block";
  } else if (elicense) {
    elicense.className = "row block";
  }

  const cpuCanvas = document.getElementById("cpu-stats") as HTMLCanvasElement;
  const memCanvas = document.getElementById(
    "memory-stats"
  ) as HTMLCanvasElement;

  const ctx = cpuCanvas?.getContext("2d");
  const ctx2 = memCanvas?.getContext("2d");

  function createCanv(r) {
    r.font = "2rem SF Mono";
    r.lineWidth = 17;
    r.fontWeight = 700;
    r.fillStyle = "#2f2768";
    r.strokeStyle = "#E8C01A";
    r.textAlign = "center";
  }

  if (ctx) {
    createCanv(ctx);
  }
  if (ctx2) {
    createCanv(ctx2);
  }

  let cw = ctx.canvas.width;
  let ch = ctx.canvas.height;

  function setProgress(ele, diff) {
    ele.clearRect(0, 0, cw, ch);
    ele.fillText(diff.toFixed(0) + "%", cw * 0.52, ch * 0.5 + 12, cw + 12);
    ele.beginPath();
    ele.arc(100, 100, 75, 0, (Math.PI * diff) / 50);
    ele.stroke();
  }

  const units = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

  function slowBytes(x) {
    let l = 0;
    let n = parseInt(x, 10) || 0;

    while (n >= 1024 && ++l) {
      n = n / 1024;
    }

    return n.toFixed(n < 10 && l > 0 ? 1 : 0) + " " + units[l];
  }

  socketRuntime.addEventListener("open", () => {
    socketRuntime.send("loop");
  });

  socket.addEventListener("open", () => {
    socket.send("config");
    socket.send("list-files");
    socket.send("list-engines");
    socket.send("list-totals");

    setTimeout(() => {
      socket.send("list-campaign-stats");
    });
  });

  const netstats = document.getElementById("network-stats");
  const netstatsUp = document.getElementById("network-stats-up");
  const netstatsTotal = document.getElementById("network-stats-total");

  // settings
  const settingsContainer = document.getElementById("settings-container");
  const settingsBtn = document.getElementById("settings-button");
  // modals first button adds close event
  const settingsBtnCls = document.querySelectorAll(".settings-bar button");

  // new create
  const campaignCreateForm = document.getElementById("campaign-create-form");

  // tor
  const torSelect = document.getElementById("tor-select") as HTMLInputElement;
  const proxySelect = document.getElementById(
    "proxy-select"
  ) as HTMLInputElement;
  const lowpowerSelect = document.getElementById(
    "lowpower-select"
  ) as HTMLInputElement;
  const fileSelect = document.getElementById(
    "target-select"
  ) as HTMLInputElement;
  const targetSelect = document.getElementById(
    "target-select"
  ) as HTMLInputElement;

  settingsBtn?.addEventListener("click", () => {
    settingsContainer.className = "block";
  });

  // set all close buttons to close menu
  for (let i = 0; i < settingsBtnCls.length; i++) {
    settingsBtnCls[i].addEventListener("click", function () {
      settingsContainer.className = "hidden";
      campaignCreateForm.className = "hidden";
    });
  }

  /*
   * List of web socket matchers * special for high performance
   */
  const estats = "{" + '"' + "stats"; // os stats
  const bftc = "{" + '"' + "buffer" + '"'; // buffer
  const ptp = "{" + '"' + "pengine" + '"' + ":" + '"'; // engine
  const selectFile = "{" + '"' + "fpath" + '"' + ":" + '"'; // selected file
  const ptpe = "{" + '"' + "epath" + '"' + ":" + '"'; // engine created
  const ptc = "{" + '"' + "count" + '"'; // file count
  const dfpath = "{" + '"' + "dfpath" + '"'; // deleted file
  const deptc = "{" + '"' + "depath" + '"'; // deleted campaign
  const cfin = "{" + '"' + "finished" + '"'; // crawl finished
  const vpaths = "{" + '"' + "path" + '"' + ":" + '"'; // valid paths
  const ipaths = "{" + '"' + "invalid_path" + '"' + ":" + '"'; // invalid paths
  const epaths = "{" + '"' + "error_path" + '"' + ":" + '"'; // errors paths
  const vlicense = "{" + '"' + "license"; // valid license;
  const cstarted = "{" + '"' + "started"; // started campaigns from pause
  const cpaused = "{" + '"' + "paused"; // paused campaigns from pause

  // defaults for program entry
  let defaultOptionSet = false;
  let firstCheck = false;

  function determineFinished(item: EngineProps) {
    return (
      item.errorUrls.size + item.invalidUrls.size + item.urls.size ===
      item.total
    );
  }

  function eventSub(event) {
    const raw = event.data;

    // license handling
    if (raw.startsWith(vlicense)) {
      const data = JSON.parse(raw);
      const { license } = data || {};

      // set local storage of license enabled and display view
      if (license) {
        if (program) {
          program.className = "row";
        }
        if (elicense) {
          elicense.className = "row hidden";
        }
        localStorage.setItem("authed", "true");
      } else {
        localStorage.removeItem("authed");

        if (firstCheck) {
          window.alert("License is invalid");
        }

        if (program) {
          program.className = "row hidden";
        }

        if (elicense) {
          elicense.className = "row";
        }
      }

      if (!firstCheck) {
        firstCheck = true;
      }
    }

    if (raw.startsWith(selectFile)) {
      const np = JSON.parse(raw);

      return selectedFileOptionMutate({
        path: np.fpath,
        fileSelect,
      });
    }

    if (raw.startsWith(estats)) {
      const data = JSON.parse(raw);
      const {
        cpu_usage,
        // load_avg_min,
        network_received,
        network_transmited,
        network_total_transmitted,
        memory_free,
        // memory_used,
        memory_total,
      } = data.stats;

      if (ctx) {
        setProgress(ctx, cpu_usage);
      }
      if (ctx2) {
        setProgress(ctx2, (memory_free / memory_total) * 100);
      }

      if (netstats) {
        netstats.innerHTML = `${slowBytes(network_received)} / s`;
      }

      if (netstatsUp) {
        netstatsUp.innerHTML = `${slowBytes(network_transmited)} / s`;
      }

      if (netstatsTotal) {
        netstatsTotal.innerHTML = slowBytes(network_total_transmitted);
      }

      return;
    }

    if (raw.startsWith(cfin)) {
      const data = JSON.parse(raw);
      const { finished, time } = data || {};

      setStatus(finished, CellStatus.FINISHED);
      console.log(time);
      return;
    }

    if (raw.startsWith(ptp)) {
      const np = JSON.parse(raw);
      const { pengine, ploc } = np || {};
      const eitem = engines.get()[pengine];

      if (eitem) {
        eitem.total = ploc ?? eitem.total ?? 0;

        engines.notify(pengine);

        if (determineFinished(eitem)) {
          setStatus(pengine, CellStatus.FINISHED);
        }
      }

      return;
    }

    if (raw.startsWith(epaths)) {
      const np = JSON.parse(raw);
      const { error_path, error_url } = np || {};
      const item = engines.get()[error_path];

      if (
        item &&
        error_url &&
        item.errorUrls &&
        !item.errorUrls.has(error_url)
      ) {
        item.errorUrls.add(error_url);

        if (selectedEngine.get() === error_path) {
          addErrorLogs(error_url);
        }

        if (determineFinished(item)) {
          setStatus(error_path, CellStatus.FINISHED);
        }

        engines.notify(error_path);
      }

      return;
    }

    if (raw.startsWith(ipaths)) {
      const np = JSON.parse(raw);

      const { invalid_url: url, invalid_path: path } = np || {};

      const item = engines.get()[path];

      if (item && item.invalidUrls && !item.invalidUrls.has(url)) {
        item.invalidUrls.add(url);

        if (selectedEngine.get() === path) {
          addInvalidLogs(url);
        }
        if (determineFinished(item)) {
          setStatus(path, CellStatus.FINISHED);
        }
      }

      return;
    }

    if (raw.startsWith(vpaths)) {
      const np = JSON.parse(raw);
      const { url, path } = np || {};
      const item = engines.get()[path];

      if (item && url && item.urls && !item.urls.has(url)) {
        item.urls.add(url);
        if (selectedEngine.get() === path) {
          addValidLogs(url);
        }
        if (determineFinished(item)) {
          setStatus(path, CellStatus.FINISHED);
        }
      }

      return;
    }

    if (raw.startsWith(ptpe)) {
      const np = JSON.parse(raw);
      const path = np && (np.epath as string);

      if (!engines.get()[path]) {
        const engineSource = {
          total: 0,
          valid: 0,
          urls: new Set(),
          invalidUrls: new Set(),
          errorUrls: new Set(),
          patterns: np?.patterns,
          paths: np?.paths,
          status: CellStatus.READY,
        };

        engines.setKey(path, engineSource);
      }
      return;
    }

    if (raw.startsWith(cstarted)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        setStatus(path, CellStatus.RUNNING);
      }
      return;
    }

    if (raw.startsWith(cpaused)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        setStatus(path, CellStatus.PAUSED);
      }
      return;
    }

    if (raw.startsWith(ptc)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        item.valid = np.count ?? item.valid ?? 0;
        engines.notify(path);

        if (determineFinished(item)) {
          setStatus(path, CellStatus.FINISHED);
        }
      }
      return;
    }

    if (raw.startsWith(dfpath)) {
      const np = JSON.parse(raw);
      const path = np && np.dfpath;

      if (fileMap.has(path)) {
        const kid = "fskeys_" + path;
        const cell = document.getElementById(kid);
        cell.remove();
        fileMap.delete(path);
      }
      return;
    }

    // settings
    if (raw.startsWith(bftc)) {
      const np = JSON.parse(raw);

      if (!defaultOptionSet) {
        defaultOptionSet = true;

        if (proxySelect) {
          proxySelect.checked = np.proxy;
        }

        if (lowpowerSelect) {
          lowpowerSelect.checked = !!np.buffer;
        }

        if (torSelect) {
          torSelect.checked = np.tor;
        }

        if (targetSelect) {
          targetSelect.value = np.target;
          baseConfig.initialTarget = np.target;
        }
      }
      return;
    }

    // delete engine
    if (raw.startsWith(deptc)) {
      const np = JSON.parse(raw);
      const path = np && np.depath;

      if (engines.get()[path]) {
        engines.setKey(path, undefined);
      }
      return;
    }
  }

  socket.addEventListener("message", eventSub);
  socketRuntime.addEventListener("message", eventSub);

  const eform = document.getElementById("eform");
  const bufferform = document.getElementById("bufferform");
  const fsDelete = document.getElementById("fs-delete");

  bufferform?.addEventListener("submit", (event) => {
    const buffer: HTMLInputElement = bufferform.querySelector(
      'input[name="buffer"]'
    );
    const selected = buffer.value;

    socket.send("set-buffer " + selected);

    event.preventDefault();
  });

  fileSelect?.addEventListener("change", function (event) {
    socket.send("set-list " + this.value);
    event.preventDefault();
  });

  torSelect?.addEventListener("change", function (event) {
    socket.send("set-tor " + this.checked);
    event.preventDefault();
  });

  proxySelect?.addEventListener("change", function (event) {
    socket.send("set-proxy " + this.checked);
    event.preventDefault();
  });

  lowpowerSelect?.addEventListener("change", function (event) {
    socket.send("set-buffer " + this.checked);
    event.preventDefault();
  });

  fsDelete?.addEventListener("click", async () => {
    const cf = await window.confirm(
      "Are, you sure you want to delete this file?"
    );

    if (cf) {
      const selected = fileSelect?.value;

      if (selected) {
        socket.send("delete-file " + selected);
      }
    }
  });

  eform?.addEventListener("submit", (event) => {
    const engine: HTMLInputElement = eform.querySelector('input[name="ename"]');
    const epaths: HTMLInputElement = eform.querySelector(
      'input[name="epaths"]'
    );
    const epatterns: HTMLInputElement = eform.querySelector(
      'input[name="epatterns"]'
    );

    if (engine && engine.value) {
      const m = JSON.stringify({
        name: engine.value,
        paths: epaths.value,
        patterns: epatterns.value,
      });

      campaignCreateForm.className = "hidden";

      if (engines.get()[m]) {
        window.alert("Please enter a different engine name.");
      } else {
        // todo: send new engine created on submit or add optimistic update
        socket.send("create-engine " + m);
        socket.send("list-engines");
      }
    } else {
      window.alert("Please enter a engine name.");
    }
    event.preventDefault();
  });
</script>
