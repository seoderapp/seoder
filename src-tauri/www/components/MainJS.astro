---
declare global {
  var __TAURI__: any;
}
---

<script>
  import {
    addErrorLogs,
    addValidLogs,
    engines,
    errorLogs,
    fileMap,
    selectedEngine,
    setStatus,
    validLogs,
  } from "../stores/engine";
  import { socket, socketRuntime, initSockets } from "../events/sockets";

  import { CellStatus } from "./CampaignCell";

  initSockets();

  // license control [determine screens] quickly
  const program = document.getElementById("appProgram");
  const elicense = document.getElementById("elicense");

  if (program && localStorage.getItem("authed")) {
    program.className = "row block";
  } else if (elicense) {
    elicense.className = "row block";
  }

  const cpuCanvas = document.getElementById("cpu-stats") as HTMLCanvasElement;
  const memCanvas = document.getElementById(
    "memory-stats"
  ) as HTMLCanvasElement;

  const ctx = cpuCanvas?.getContext("2d");
  const ctx2 = memCanvas?.getContext("2d");

  function createCanv(r) {
    r.font = "2rem SF Mono";
    r.lineWidth = 17;
    r.fontWeight = 700;
    r.fillStyle = "#2f2768";
    r.strokeStyle = "#E8C01A";
    r.textAlign = "center";
  }

  if (ctx) {
    createCanv(ctx);
  }
  if (ctx2) {
    createCanv(ctx2);
  }

  function setProgress(ele, diff) {
    let cw = ele.canvas.width;
    let ch = ele.canvas.height;
    ele.clearRect(0, 0, cw, ch);
    ele.fillText(diff.toFixed(0) + "%", cw * 0.52, ch * 0.5 + 5, cw + 12);
    ele.beginPath();
    ele.arc(100, 100, 75, 0, (Math.PI * diff) / 50);
    ele.stroke();
  }

  const units = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

  function slowBytes(x) {
    let l = 0;
    let n = parseInt(x, 10) || 0;

    while (n >= 1024 && ++l) {
      n = n / 1024;
    }

    return n.toFixed(n < 10 && l > 0 ? 1 : 0) + " " + units[l];
  }

  socketRuntime.addEventListener("open", () => {
    socketRuntime.send("loop");
  });

  socket.addEventListener("open", () => {
    socket.send("list-engines");
    socket.send("list-totals");
    socket.send("list-files");
    socket.send("feed");
    socket.send("config");

    setTimeout(() => {
      socket.send("list-campaign-stats");
    });
  });

  const netstats = document.getElementById("network-stats");
  const netstatsUp = document.getElementById("network-stats-up");
  const netstatsTotal = document.getElementById("network-stats-total");

  // settings
  const settingsContainer = document.getElementById("settings-container");
  const settingsBtn = document.getElementById("settings-button");
  // modals first button adds close event
  const settingsBtnCls = document.querySelectorAll(".settings-bar button");

  // new create
  const newCampaignButton = document.getElementById("new-campaign-button");
  const campaignCreateForm = document.getElementById("campaign-create-form");

  // tor
  const torSelect = document.getElementById("tor-select") as HTMLInputElement;
  const proxySelect = document.getElementById(
    "proxy-select"
  ) as HTMLInputElement;
  const lowpowerSelect = document.getElementById(
    "lowpower-select"
  ) as HTMLInputElement;
  const fileSelect = document.getElementById(
    "target-select"
  ) as HTMLInputElement;

  newCampaignButton?.addEventListener("click", () => {
    campaignCreateForm.className = "block";
  });

  settingsBtn?.addEventListener("click", () => {
    settingsContainer.className = "block";
  });

  settingsBtn?.addEventListener("click", () => {
    settingsContainer.className = "block";
  });

  // set all close buttons to close menu
  for (let i = 0; i < settingsBtnCls.length; i++) {
    settingsBtnCls[i].addEventListener("click", function () {
      settingsContainer.className = "hidden";
      campaignCreateForm.className = "hidden";
    });
  }

  let initialTarget = "";

  /*
   * List of web socket matchers * special for high performance
   */
  const bftc = "{" + '"' + "buffer" + '"'; // buffer
  const ptp = "{" + '"' + "pengine" + '"' + ":" + '"'; // engine
  const selectFile = "{" + '"' + "fpath" + '"' + ":" + '"'; // selected file
  const ptpe = "{" + '"' + "epath" + '"' + ":" + '"'; // engine created
  const ptc = "{" + '"' + "count" + '"'; // file count
  const dfpath = "{" + '"' + "dfpath" + '"'; // deleted file
  const deptc = "{" + '"' + "depath" + '"'; // deleted campaign
  const cfin = "{" + '"' + "finished" + '"'; // crawl finished
  const vpaths = "{" + '"' + "path" + '"' + ":" + '"'; // valid paths
  const ipaths = "{" + '"' + "invalid_path" + '"' + ":" + '"'; // invalid paths
  const vlicense = "{" + '"' + "license"; // valid license;

  // defaults for program entry
  let defaultOptionSet = false;
  let firstCheck = false;

  function eventSub(event) {
    const raw = event.data;

    // license handling
    if (raw.startsWith(vlicense)) {
      const data = JSON.parse(raw);
      const { license } = data || {};

      // set local storage of license enabled and display view
      if (license) {
        if (program) {
          program.className = "row";
        }
        if (elicense) {
          elicense.className = "row hidden";
        }
        localStorage.setItem("authed", "true");
      } else {
        if (firstCheck) {
          window.alert("License is invalid");
        }

        if (program) {
          program.className = "row hidden";
        }

        if (elicense) {
          elicense.className = "row";
        }

        localStorage.removeItem("authed");
      }

      if (!firstCheck) {
        firstCheck = true;
      }
    }

    if (raw.startsWith("{" + '"' + "stats")) {
      const data = JSON.parse(raw);
      const {
        cpu_usage,
        // load_avg_min,
        network_received,
        network_transmited,
        network_total_transmitted,
        memory_free,
        // memory_used,
        memory_total,
      } = data.stats;

      if (ctx) {
        setProgress(ctx, cpu_usage);
      }
      if (ctx2) {
        setProgress(ctx2, (memory_free / memory_total) * 100);
      }

      if (netstats) {
        netstats.innerHTML = `${slowBytes(network_received)} / s`;
      }

      if (netstatsUp) {
        netstatsUp.innerHTML = `${slowBytes(network_transmited)} / s`;
      }

      if (netstatsTotal) {
        netstatsTotal.innerHTML = slowBytes(network_total_transmitted);
      }

      return;
    }

    if (raw.startsWith(cfin)) {
      const data = JSON.parse(raw);
      const { finished, time } = data || {};

      setStatus(finished, CellStatus.FINISHED);
      console.log(time);
      return;
    }

    if (raw.startsWith(ptp)) {
      const np = JSON.parse(raw);
      const { pengine, ploc } = np || {};
      const eitem = engines.get()[pengine];

      if (eitem) {
        eitem.total = ploc ?? eitem.total ?? 0;

        engines.notify(pengine);
      }

      return;
    }

    if (raw.startsWith(ipaths)) {
      const np = JSON.parse(raw);
      const { invalid_url: url, invalid_path: path } = np || {};

      const item = engines.get()[path];

      if (item && url && item.invalidUrls && !item.invalidUrls.has(url)) {
        item.invalidUrls.add(url);
        if (selectedEngine.get() === path) {
          addErrorLogs(url);
        }
      }

      return;
    }

    if (raw.startsWith(vpaths)) {
      const np = JSON.parse(raw);
      const { url, path } = np || {};
      const item = engines.get()[path];

      if (item && url && item.urls && !item.urls.has(url)) {
        item.urls.add(url);
        if (selectedEngine.get() === path) {
          addValidLogs(url);
        }
      }

      return;
    }

    if (raw.startsWith(selectFile)) {
      const np = JSON.parse(raw);
      const path = np && np.fpath;

      if (!fileMap.has(path)) {
        fileMap.set(path, {});
        // file select

        if (fileSelect) {
          if (initialTarget) {
            const kid = "fskeys_" + initialTarget;
            const item = document.getElementById(kid);
            if (!item) {
              const cellSelect: HTMLOptionElement =
                document.createElement("option");

              cellSelect.id = kid;
              // @ts-ignore
              cellSelect.name = "fsselect";
              cellSelect.value = initialTarget;
              cellSelect.innerText = initialTarget;

              fileSelect.appendChild(cellSelect);
            }
          }

          for (const [key, _] of fileMap) {
            if (key !== initialTarget) {
              const kid = "fskeys_" + key;
              const item = document.getElementById(kid);

              if (!item) {
                const cellSelect: HTMLOptionElement =
                  document.createElement("option");

                cellSelect.id = kid;
                // @ts-ignore
                cellSelect.name = "fsselect";
                cellSelect.value = key;
                cellSelect.innerText = key;

                fileSelect.appendChild(cellSelect);
              }
            }
          }
        }
      }
      return;
    }

    if (raw.startsWith(ptpe)) {
      const np = JSON.parse(raw);
      const path = np && (np.epath as string);

      if (!engines.get()[path]) {
        const engineSource = {
          total: 0,
          valid: 0,
          urls: new Set(),
          invalidUrls: new Set(),
          patterns: np?.patterns,
          paths: np?.paths,
          status: CellStatus.READY,
        };

        engines.setKey(path, engineSource);
      }
      return;
    }

    if (raw.startsWith(ptc)) {
      const np = JSON.parse(raw);
      const path = np && np.path;
      const item = engines.get()[path];

      if (item) {
        item.valid = np.count ?? item.valid ?? 0;
        engines.notify(path);
      }
      return;
    }

    if (raw.startsWith(dfpath)) {
      const np = JSON.parse(raw);
      const path = np && np.dfpath;

      if (fileMap.has(path)) {
        const kid = "fskeys_" + path;
        const cell = document.getElementById(kid);

        cell.remove();

        fileMap.delete(path);
      }
      return;
    }

    // settings
    if (raw.startsWith(bftc)) {
      const np = JSON.parse(raw);

      if (!defaultOptionSet) {
        defaultOptionSet = true;
        initialTarget = np.target;

        if (proxySelect) {
          proxySelect.checked = np.proxy;
        }
        if (lowpowerSelect) {
          lowpowerSelect.checked = !!np.buffer;
        }

        if (torSelect) {
          torSelect.checked = np.tor;
        }
      }
      return;
    }

    // delete engine
    if (raw.startsWith(deptc)) {
      const np = JSON.parse(raw);
      const path = np && np.depath;

      if (engines.get()[path]) {
        engines.setKey(path, undefined);
      }
    }
  }

  socket.addEventListener("message", eventSub);
  socketRuntime.addEventListener("message", eventSub);

  const rsform = document.getElementById("rsform");
  const rform = document.getElementById("rform");
  const eform = document.getElementById("eform");
  const uploadform = document.getElementById("uploadform");
  const bufferform = document.getElementById("bufferform");
  const fsDelete = document.getElementById("fs-delete");

  uploadform?.addEventListener("submit", (event) => {
    event.preventDefault();
    const url = "http://localhost:7050/upload";
    const request = new XMLHttpRequest();

    request.open("POST", url, true);

    request.onload = function () {};

    request.onerror = function () {
      // request failed
    };

    request.send(new FormData(event.target as HTMLFormElement));
  });

  rsform?.addEventListener("submit", (event) => {
    event.preventDefault();
    const selected = selectedEngine.get();
    const eitem = engines.get()[selected];

    if (selected) {
      // js objects
      eitem.urls.clear();
      eitem.invalidUrls.clear();
      eitem.status = CellStatus.RUNNING;

      engines.notify(selected);

      validLogs.set([]);
      errorLogs.set([]);

      socket.send("run-campaign " + selected);
    } else {
      alert("Please select a campaign");
    }
  });

  rform?.addEventListener("submit", (event) => {
    const allEngines = engines.get();

    Object.keys(allEngines).forEach((key) => {
      const item = allEngines[key];

      allEngines[key] = {
        ...item,
        status: CellStatus.RUNNING,
      };
    });

    engines.set(allEngines);

    socket.send("run-all-campaigns");
    event.preventDefault();
  });

  bufferform?.addEventListener("submit", (event) => {
    const buffer: HTMLInputElement = bufferform.querySelector(
      'input[name="buffer"]'
    );
    const selected = buffer.value;

    socket.send("set-buffer " + selected);

    event.preventDefault();
  });

  fileSelect?.addEventListener("change", function (event) {
    socket.send("set-list " + this.value);
    event.preventDefault();
  });

  torSelect?.addEventListener("change", function (event) {
    socket.send("set-tor " + this.checked);
    event.preventDefault();
  });

  proxySelect?.addEventListener("change", function (event) {
    socket.send("set-proxy " + this.checked);
    event.preventDefault();
  });

  lowpowerSelect?.addEventListener("change", function (event) {
    socket.send("set-buffer " + this.checked);
    event.preventDefault();
  });

  fsDelete?.addEventListener("click", () => {
    const cf = window.confirm("Are, you sure you want to delete this file?");

    if (cf) {
      const campaign: HTMLInputElement = fileSelect.querySelector(
        'select[name="target"]'
      );
      const selected = campaign.value;

      socket.send("delete-file " + selected);
    }
  });

  eform?.addEventListener("submit", (event) => {
    const engine: HTMLInputElement = eform.querySelector('input[name="ename"]');
    const epaths: HTMLInputElement = eform.querySelector(
      'input[name="epaths"]'
    );
    const epatterns: HTMLInputElement = eform.querySelector(
      'input[name="epatterns"]'
    );

    if (engine && engine.value) {
      const m = JSON.stringify({
        name: engine.value,
        paths: epaths.value,
        patterns: epatterns.value,
      });

      campaignCreateForm.className = "hidden";

      // todo: send new engine created on submit or add optimistic update
      socket.send("create-engine " + m);
      socket.send("list-engines");
    } else {
      window.alert("Please enter a engine name");
    }
    event.preventDefault();
  });

  elicense?.addEventListener("submit", (event) => {
    const slicense: HTMLInputElement = elicense.querySelector(
      'input[name="license"]'
    );

    if (slicense && slicense.value) {
      socket.send("set-license " + slicense.value);
    } else {
      window.alert("Please enter a license.");
    }
    event.preventDefault();
  });

  const ulicense = document.getElementById("ulicense");

  ulicense?.addEventListener("submit", (event) => {
    const slicense: HTMLInputElement = ulicense.querySelector(
      'input[name="license"]'
    );

    if (slicense && slicense.value) {
      socket.send("set-license " + slicense.value);
    } else {
      window.alert("Please enter a license.");
    }
    event.preventDefault();
  });
</script>
